<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VanillaDtoRegistry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenHFT/Chronicle-Decentred</a> &gt; <a href="index.source.html" class="el_package">net.openhft.chronicle.decentred.util</a> &gt; <span class="el_source">VanillaDtoRegistry.java</span></div><h1>VanillaDtoRegistry.java</h1><pre class="source lang-java linenums">package net.openhft.chronicle.decentred.util;

import net.openhft.chronicle.bytes.MethodId;
import net.openhft.chronicle.core.Jvm;
import net.openhft.chronicle.core.Maths;
import net.openhft.chronicle.core.util.ObjectUtils;
import net.openhft.chronicle.decentred.api.SystemMessages;
import net.openhft.chronicle.decentred.dto.DtoAliases;
import net.openhft.chronicle.decentred.dto.VanillaSignedMessage;

import java.lang.reflect.Method;
import java.util.LinkedHashMap;
import java.util.Map;

import static java.util.Objects.requireNonNull;
import static net.openhft.chronicle.decentred.util.DecentredUtil.MASK_16;

/**
 * This class is not thread safe although, once configured, the {@link #get()} method
 * can be invoked in a thread safe way.
 *
 * @param &lt;T&gt; the type of the super interface for all dto:s
 */
<span class="pc bpc" id="L24" title="1 of 2 branches missed.">public final class VanillaDtoRegistry&lt;T&gt;  implements DtoRegistry&lt;T&gt; {</span>
    static {
<span class="fc" id="L26">        DtoAliases.addAliases();</span>
<span class="fc" id="L27">    }</span>

    private final Class&lt;T&gt; superInterface;
<span class="fc" id="L30">    private final Map&lt;Class, Integer&gt; classToProtocolMessageType = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L31">    private final IntObjMap&lt;DtoParselet&gt; parseletMap = IntObjMap.withExpectedSize(DtoParselet.class, 128);</span>
<span class="fc" id="L32">    private final Map&lt;Class, Method&gt; classConsumerMap = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L34">    VanillaDtoRegistry(Class&lt;T&gt; superInterface) {</span>
<span class="fc" id="L35">        this.superInterface = requireNonNull(superInterface);</span>
<span class="fc" id="L36">        addProtocol(0xFFFF, (Class) SystemMessages.class); // Todo: T or super type?</span>
<span class="fc" id="L37">    }</span>
    @Override
    public VanillaDtoRegistry&lt;T&gt; addProtocol(int protocol, Class&lt;? super T&gt; pClass) {
<span class="pc bpc" id="L40" title="1 of 2 branches missed.">        if (protocol &lt; 0) {</span>
<span class="nc" id="L41">            throw new IllegalArgumentException(&quot;protocol cannot be negative:&quot; + protocol);</span>
        }
<span class="fc" id="L43">        requireNonNull(pClass);</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">        for (Method method : pClass.getMethods()) {</span>
<span class="fc" id="L45">            final MethodId mid = method.getAnnotation(MethodId.class);</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">            if (mid != null) {</span>
<span class="pc bpc" id="L47" title="2 of 4 branches missed.">                assert (mid.value() | MASK_16) == MASK_16;</span>
<span class="fc" id="L48">                final int key = (int) ((protocol &lt;&lt; 16) + mid.value());</span>
                try {
<span class="fc" id="L50">                    parseletMap.justPut(key,</span>
<span class="fc" id="L51">                            new DtoParselet(method, protocol, Maths.toUInt16(mid.value())));</span>
<span class="fc" id="L52">                    final Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">                    if (parameterTypes.length != 1) {</span>
<span class="nc" id="L54">                        Jvm.warn().on(getClass(), &quot;Methods must have 1 parameter &quot; + method);</span>
<span class="nc" id="L55">                        continue;</span>
                    }
<span class="fc" id="L57">                    final Class&lt;?&gt; parameterType = parameterTypes[0];</span>
<span class="fc" id="L58">                    classToProtocolMessageType.put(parameterType, key);</span>
<span class="fc" id="L59">                    classConsumerMap.putIfAbsent(parameterType, method);</span>
<span class="nc" id="L60">                } catch (Exception e) {</span>
<span class="nc" id="L61">                    throw new IllegalArgumentException(e);</span>
<span class="fc" id="L62">                }</span>
            }
        }
<span class="fc" id="L65">        return this;</span>
    }

    @Override
    public int protocolFor(Class clazz) {
<span class="fc" id="L70">        return protocolMessageTypeFor(clazz) &gt;&gt;&gt; 16;</span>
    }

    @Override
    public int messageTypeFor(Class clazz) {
<span class="fc" id="L75">        return protocolMessageTypeFor(clazz) &amp; MASK_16;</span>
    }

    @Override
    public int protocolMessageTypeFor(Class clazz) {
<span class="fc" id="L80">        requireNonNull(clazz);</span>
<span class="fc" id="L81">        final Integer pmt = classToProtocolMessageType.get(clazz);</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (pmt == null) {</span>
<span class="nc" id="L83">            throw new IllegalStateException(clazz + &quot; not defined&quot;);</span>
        }
<span class="fc" id="L85">        return pmt;</span>
    }

    @Override
    public DtoParser&lt;T&gt; get() {
<span class="fc" id="L90">        final IntObjMap&lt;DtoParselet&gt; parseletMap2 = IntObjMap.withExpectedSize(DtoParselet.class, parseletMap.size() * 2);</span>
<span class="fc" id="L91">        parseletMap.forEach((i, dp) -&gt; parseletMap2.justPut(i, new DtoParselet(dp)));</span>
<span class="fc" id="L92">        VanillaDtoParser&lt;T&gt; dtoParser = new VanillaDtoParser&lt;&gt;(superInterface, parseletMap2, classConsumerMap);</span>
<span class="fc" id="L93">        parseletMap2.forEach((i, p) -&gt; p.dtoRegistry(this));</span>
<span class="fc" id="L94">        return dtoParser;</span>
    }

    @Override
    public &lt;M extends VanillaSignedMessage&lt;M&gt;&gt; M create(Class&lt;M&gt; tClass) {
<span class="fc" id="L99">        requireNonNull(tClass);</span>
<span class="fc" id="L100">        final int pmt = protocolMessageTypeFor(tClass);</span>
        try {
<span class="fc" id="L102">            final int protocol = pmt &gt;&gt;&gt; 16;</span>
<span class="fc" id="L103">            final int messageType = pmt &amp; MASK_16;</span>
<span class="fc" id="L104">            final M vsm = ObjectUtils.newInstance(tClass);</span>
<span class="fc" id="L105">            return vsm.protocol(protocol).messageType(messageType);</span>
<span class="nc" id="L106">        } catch (Exception e) {</span>
<span class="nc" id="L107">            throw new AssertionError(e);</span>
        }
    }

    @Override
    public Class&lt;T&gt; superInterface() {
<span class="fc" id="L113">        return superInterface;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>